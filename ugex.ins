;;; -*- syntax: common-lisp; base: 10; mode: lisp -*-(definstrument gran-synth (start-time duration audio-freq grain-dur grain-interval amp)  (multiple-value-bind (beg end) (get-beg-end start-time duration)    (let* ((grain-env (make-env :envelope '(0 0 25 1 75 1 100 0)				:start-time 0 :duration grain-dur))	   (carrier (make-oscil :frequency audio-freq))	   (grain-size (ceiling (* (max grain-dur grain-interval) sampling-rate)))	   (grain (make-short-float-array grain-size))	   (grains (make-wave-train :wave grain :frequency (/ 1.0 grain-interval))))      (loop for i from 0 below grain-size do	   (setf (aref grain i) (make-short-float (* (env grain-env) (oscil carrier)))))      (run       (loop for i from beg to end do	    (outa i (* amp (wave-train grains))))))))	 ;;; (with-sound () (gran-synth 0 2 100 .0189 .02 .4));;; --------(setf touch-tab-1 '(0 697 697 697 770 770 770 852 852 852 941 941 941))(setf touch-tab-2 '(0 1209 1336 1477 1209 1336 1477 1209 1336 1477 1209 1336 1477)) (definstrument touch-tone-telephone (telephone-number)  (loop for k in telephone-number and             beg from 0 by (floor (* .4 sampling-rate)) do    (let* ((i (if (integerp k)		  (if (/= 0 k) k 11)		(if (eq k '*) 10 12)))	   (frq1 (make-oscil :frequency (nth i touch-tab-1)))	   (frq2 (make-oscil :frequency (nth i touch-tab-2)))	   (end (floor (+ beg (* .3 sampling-rate)))))      (run       (loop for j from beg to end do	 (outa j (* 0.25 (+ (oscil frq1) (oscil frq2)))))))));;; (with-sound () (touch-tone-telephone '(7 2 3 4 9 7 1));;; --------(definstrument spectrum (start-time duration frequency amplitude		         &optional (partials '(1 1 2 0.5))			           (amp-envelope '(0 0 50 1 100 0))			           (vibrato-amplitude 0.005)			           (vibrato-speed 5.0)			           (degree 0.0)			           (distance 1.0)			           (reverb-amount 0.005))  (multiple-value-bind (beg end) (get-beg-end start-time duration)    (let* ((waveform (load-synthesis-table partials (make-table)))	   (freq-in-hz (in-hz frequency))	   (s (make-table-lookup :frequency frequency :wave-table waveform))	   (amp-env (make-env :envelope amp-envelope :scaler amplitude))	   (per-vib (make-triangle-wave :frequency vibrato-speed					:amplitude (* vibrato-amplitude freq-in-hz)))	   (loc (make-locsig :degree degree :distance distance :revscale reverb-amount))	   (ran-vib (make-randi :frequency (+ vibrato-speed 1.0)				:amplitude (* vibrato-amplitude freq-in-hz))))      (run        (loop for i from beg to end do	 (locsig loc i (* (env amp-env) 			  (table-lookup s (+ (triangle-wave per-vib)					     (randi ran-vib))))))))));;; (with-sound ()  (spectrum 0 1 440.0 .1 p-a4 '(0.0 0.0 1.0 1.0 5.0 0.9 12.0 0.5 25.0 0.25 100.0 0.0));;; using p-a4 from spectr.clm;;; --------;;; interpolate between two waveforms (this could be extended to implement all the various;;; wavetable-based synthesis techniques).(definstrument two-tab (start-time duration frequency amplitude		        &optional (partial-1 '(1.0 1.0 2.0 0.5))			          (partial-2 '(1.0 0.0 3.0 1.0))			          (amp-envelope '(0 0 50 1 100 0))			          (interp-func '(0 1 100 0))			          (vibrato-amplitude 0.005)			          (vibrato-speed 5.0)			          (degree 0.0)			          (distance 1.0)			          (reverb-amount 0.005))  (multiple-value-bind (beg end) (get-beg-end start-time duration)    (let* ((waveform-1 (load-synthesis-table partial-1 (make-table)))	   (waveform-2 (load-synthesis-table partial-2 (make-table)))	   (freq-in-hz (in-hz frequency))	   (s-1 (make-table-lookup :frequency frequency :wave-table waveform-1))	   (s-2 (make-table-lookup :frequency frequency :wave-table waveform-2))	   (amp-env (make-env :envelope amp-envelope :scaler amplitude))	   (interp-env (make-env :envelope interp-func))	   (loc (make-locsig :degree degree :distance distance :revscale reverb-amount))	   (per-vib (make-triangle-wave :frequency vibrato-speed					:amplitude (* vibrato-amplitude freq-in-hz)))	   (ran-vib (make-randi :frequency (+ vibrato-speed 1.0)				:amplitude (* vibrato-amplitude freq-in-hz))))      (run       (loop for i from beg to end do	 (let ((vib (+ (triangle-wave per-vib) 		       (randi ran-vib)))	       (intrp (env interp-env)))	   (locsig loc i (* (env amp-env) 			    (+ (* intrp (table-lookup s-1 vib))			       (* (- 1.0 intrp) 				  (table-lookup s-2 vib)))))))))))(defvar formants     '((I 390 1990 2550)  (E 530 1840 2480)  (AE 660 1720 2410)      (UH 520 1190 2390) (A 730 1090 2440)  (OW 570 840 2410)      (U 440 1020 2240)  (OO 300 870 2240)  (ER 490 1350 1690)      (W 300 610 2200)   (LL 380 880 2575)  (R 420 1300 1600)      (Y 300 2200 3065)  (EE 260 3500 3800) (LH 280 1450 1600)      (L 300 1300 3000)  (I2 350 2300 3340) (B 200 800 1750)      (D 300 1700 2600)  (G 250 1350 2000)  (M 280 900 2200)      (N 280 1700 2600)  (NG 280 2300 2750) (P 300 800 1750)      (T 200 1700 2600)  (K 350 1350 2000)  (F 175 900 4400)      (TH 200 1400 2200) (S 200 1300 2500)  (SH 200 1800 2000)      (V 175 1100 2400)  (THE 200 1600 2200)(Z 200 1300 2500)      (ZH 175 1800 2000) (ZZ 900 2400 3800) (VV 565 1045 2400)))                   ;;formant center frequencies for a male speaker(defun get-phoneme-data (phoneme form)  (if (eql phoneme (caar form)) (cdar form)    (get-phoneme-data phoneme (cdr form))))(defun formant-table (center-freq amplitude carrier-freq)  (let* ((harm (round center-freq carrier-freq))	 (amps '(0.05  0.2  0.7  0.2  0.1))	 (tab nil)	 (partial 0))    (loop for i from 0 below (length amps) do      (setf partial (+ harm -2 i))      (if (plusp partial)	  (setf tab (append tab (list partial 				      (* amplitude (nth i amps)))))))    tab))(defun make-formant-list (phoneme frequency)  (let* ((phon (get-phoneme-data phoneme formants))	 (amps '(0.8 0.15 0.05))	 (tab nil))    (loop for i in phon and j in amps do      (setf tab (append tab (formant-table i j frequency))))    tab))(defun make-phoneme (begin-time duration frequency amplitude 		     phoneme-1 phoneme-2		     &optional (amp-envelope '(0 0 50 1 100 0))			       (interp-func '(0 1 100 0))			       (vibrato-amplitude 0.025)			       (vibrato-speed 6.0))  (two-tab begin-time duration frequency amplitude	   (make-formant-list phoneme-1 frequency)	   (make-formant-list phoneme-2 frequency)	   amp-envelope interp-func vibrato-amplitude vibrato-speed));;; (with-sound () (make-phoneme 0 1.0 150 0.5 'OO 'ER));;; --------;;; provided by C. Penrose:;;;;;; formants sliding around in white noise(defmacro zformant (R freq G x0 x2 y0 y1 y2)  `(let ((tG (* ,G (- 1.0 ,R))))     (setf ,y2 ,y1)     (setf ,y1 ,y0)     (setf ,y0 (- (+ (* tG ,x0) 		     (* 2 ,R (cos (in-hz ,freq)) ,y1)) 		  (+ (* tG ,R ,x2) 		     (* ,R ,R ,y2))))))(definstrument noi-attempt (beg dur amp R freq)  (let* ((a0 1.)	 (a1 .4)	 (a2 .25)	 (a3 .1)	 (noi (make-randh :frequency 11025 :amplitude amp))	 (vib0 (make-randh :frequency 5. :amplitude .0183))	 (vib1 (make-randh :frequency 7.07 :amplitude .013))	 (vib2 (make-randh :frequency 3.14 :amplitude .02))	 (vib3 (make-randh :frequency 8.33 :amplitude .015))	 (x2 0.0)	 (x1 0.0)	 (x0 0.0)	 (st (floor (* sampling-rate beg)))	 (nd (+ st (floor (* sampling-rate dur))))	 (f0y2 0.0) (f0y1 0.0) (f0y0 0.0)	 (f1y2 0.0) (f1y1 0.0) (f1y0 0.0)	 (f2y2 0.0) (f2y1 0.0) (f2y0 0.0)	 (f3y2 0.0) (f3y1 0.0) (f3y0 0.0))    (run      (loop for i from st to nd do	(setf x2 x1)	(setf x1 x0)	(setf x0 (randh noi))	(outa i (* amp		   (+ (zformant R (* freq (+ 1. (randh vib0))) a0 x0 x2 f0y0 f0y1 f0y2)		      (zformant R (* freq 3.006 (+ 1. (randh vib1))) a1 x0 x2 f1y0 f1y1 f1y2)		      (zformant R (* freq 3.984 (+ 1. (randh vib2))) a2 x0 x2 f2y0 f2y1 f2y2)		      (zformant R (* freq 5. (+ 1. (randh vib3))) a3 x0 x2 f3y0 f3y1 f3y2))))))));;; (with-sound () (noi-attempt 0 2 .3 .99 1200))(definstrument filter-white-noise (beg end R freq G)  (let* ((amp .5)         (f (make-formant R freq G))         (noi (make-randh :frequency 5000 :amplitude .1)))    (run      (loop for i from beg to end do        (outa i (* amp (formant f (randh noi))))))));;; (with-sound () (filter-white-noise 0 10000 .99 1000 1.0))(definstrument testR (beg end R0 R1 freq G)  (let* ((amp .5)         (f (make-formant R0 freq G))         (noi (make-randh :frequency 5000))	 (R R0)	 (incR (/ (- R1 R0) (- end beg))))    (run     (loop for i from beg to end do       (outa i (* amp (formant f (randh noi))))       (setf (formant-radius f) R)       (incf R incR)))))(definstrument pvins (beg dur file amp shift &optional (fftsize 128))  ;;assume shift is a positive integer  (let ((fil (open-input file)))    (unwind-protect	(let* ((start (floor (* beg sampling-rate)))	       (end (+ start (floor (* dur sampling-rate))))	       (fftsize-1 (1- fftsize))	       (fdr (make-short-float-array fftsize))	       (fdi (make-short-float-array fftsize))	       (wtb (make-run-block :size fftsize))	       (filptr 0)	       (freq-inc (/ fftsize 2))	       (fftn (/ 1.0 fftsize))	       (freq-inc-1 (1- freq-inc)))	  (run	   (loop for i from start to end do	     (when (triggered wtb)	       (dotimes (k fftsize)		 (setf (aref fdr k) (* (ina filptr fil) fftn))		 (incf filptr))	       (clear-array fdi)	       (decf filptr freq-inc)	       (fft fdr fdi)	       ;; now shift the positive frequencies up and the negative frequencies down	       (when (not (zerop shift))		 (loop for k from freq-inc-1 downto shift and j from freq-inc do		   (setf (aref fdr k) (aref fdr (- k shift)))		   (setf (aref fdi k) (aref fdi (- k shift)))		   (setf (aref fdr j) (aref fdr (+ j shift)))		   (setf (aref fdi j) (aref fdi (+ j shift))))		 (dotimes (k shift)		   (setf (aref fdr k) 0.0)		   (setf (aref fdi k) 0.0)		   (setf (aref fdr (- fftsize-1 k)) 0.0)		   (setf (aref fdi (- fftsize-1 k)) 0.0)))	       (inverse-fft fdr fdi)	       (dotimes (k fftsize)		 (incf (aref (rblk-buf wtb) k) (aref fdr k))) 	       (setf (trigger wtb) freq-inc))	     (outa i (* amp (run-block wtb))))))      (close-input fil))))